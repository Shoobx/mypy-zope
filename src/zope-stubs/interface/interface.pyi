from _typeshed import Incomplete
from collections.abc import Generator

class Element:
    __name__: Incomplete
    __doc__: Incomplete
    def __init__(self, __name__, __doc__: str = ...) -> None: ...
    def getName(self): ...
    def getDoc(self): ...
    def getTaggedValue(self, tag): ...
    def queryTaggedValue(self, tag, default: Incomplete | None = ...): ...
    def getTaggedValueTags(self): ...
    def setTaggedValue(self, tag, value) -> None: ...
    queryDirectTaggedValue = queryTaggedValue
    getDirectTaggedValue = getTaggedValue
    getDirectTaggedValueTags = getTaggedValueTags
SpecificationBasePy = object

class SpecificationBase:
    def providedBy(self, ob) -> bool: ...
    def implementedBy(self, cls) -> bool: ...
    def isOrExtends(self, interface) -> bool: ...
    __call__ = isOrExtends

class NameAndModuleComparisonMixin:
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...

class InterfaceBase(NameAndModuleComparisonMixin, SpecificationBase):
    __name__: Incomplete
    __ibmodule__: Incomplete
    def __init__(self, name: Incomplete | None = ..., module: Incomplete | None = ...) -> None: ...
    @property
    def __module_property__(self): ...
    def __call__(self, obj, alternate=...): ...
    def __adapt__(self, obj): ...
    def __hash__(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...

adapter_hooks: Incomplete

class Specification(SpecificationBase):
    __iro__: Incomplete
    __sro__: Incomplete
    __bases__: Incomplete
    def __init__(self, bases=...) -> None: ...
    @property
    def dependents(self): ...
    def subscribe(self, dependent) -> None: ...
    def unsubscribe(self, dependent) -> None: ...
    def changed(self, originally_changed) -> None: ...
    def interfaces(self) -> Generator[Incomplete, None, None]: ...
    def extends(self, interface, strict: bool = ...): ...
    def weakref(self, callback: Incomplete | None = ...): ...
    def get(self, name, default: Incomplete | None = ...): ...

class _InterfaceMetaClass(type):
    def __new__(cls, name, bases, attrs): ...
    @property
    def __module__(cls): ...


class InterfaceClass(type, Element, InterfaceBase, Specification):
    def __new__(cls, name: Incomplete | None = ..., bases=..., attrs: Incomplete | None = ..., __doc__: Incomplete | None = ..., __module__: Incomplete | None = ...): ...
    __identifier__: Incomplete
    def __init__(self, name, bases=..., attrs: Incomplete | None = ..., __doc__: Incomplete | None = ..., __module__: Incomplete | None = ...) -> None: ...
    def interfaces(self) -> Generator[Incomplete, None, None]: ...
    def getBases(self): ...
    def isEqualOrExtendedBy(self, other): ...
    def names(self, all: bool = ...): ...
    def __iter__(self): ...
    def namesAndDescriptions(self, all: bool = ...): ...
    def getDescriptionFor(self, name): ...
    __getitem__ = getDescriptionFor
    def __contains__(self, name) -> bool: ...
    def direct(self, name): ...
    def queryDescriptionFor(self, name, default: Incomplete | None = ...): ...
    def validateInvariants(self, obj, errors: Incomplete | None = ...) -> None: ...
    def queryTaggedValue(self, tag, default: Incomplete | None = ...): ...
    def getTaggedValue(self, tag): ...
    def getTaggedValueTags(self): ...
    def __reduce__(self): ...

class _InterfaceClassWithCustomMethods(InterfaceClass): ...

class Attribute(Element):
    interface: Incomplete

class Method(Attribute):
    positional: Incomplete
    required: Incomplete
    varargs: Incomplete
    kwargs: Incomplete
    optional: Incomplete
    def __call__(self, *args, **kw) -> None: ...
    def getSignatureInfo(self): ...
    def getSignatureString(self): ...


class Interface(metaclass=InterfaceClass): ...
